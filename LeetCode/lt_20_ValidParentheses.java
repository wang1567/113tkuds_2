import java.util.*;

class Solution {
    public boolean isValid(String s) {
        // 使用棧來存儲左括號
        Stack<Character> stack = new Stack<>();

        // 遍歷字符串中的每個字符
        for (char c : s.toCharArray()) {
            // 如果是左括號，則推入棧中
            if (c == '(' || c == '{' || c == '[') {
                stack.push(c);
            }
            // 如果是右括號，需要檢查匹配
            else if (c == ')' || c == '}' || c == ']') {
                // 如果棧為空，說明沒有對應的左括號
                if (stack.isEmpty()) {
                    return false;
                }

                // 彈出棧頂的左括號
                char left = stack.pop();

                // 檢查左右括號是否匹配
                if (!isMatching(left, c)) {
                    return false;
                }
            }
        }

        // 最後檢查棧是否為空
        // 如果棧為空，說明所有括號都已匹配；否則還有未匹配的左括號
        return stack.isEmpty();
    }

    // 輔助方法：檢查左右括號是否匹配
    private boolean isMatching(char left, char right) {
        return (left == '(' && right == ')') ||
                (left == '{' && right == '}') ||
                (left == '[' && right == ']');
    }
}

/*
 * 解題邏輯與思路詳解：
 * 
 * 【核心思路】：使用棧（Stack）數據結構
 * 
 * 1. **問題本質分析**：
 * - 括號匹配問題的核心是"後進先出"（LIFO）的特性
 * - 最近出現的左括號應該與最先遇到的右括號匹配
 * - 這正好符合棧的特性
 * 
 * 2. **算法思路**：
 * - 遇到左括號：推入棧中（等待匹配）
 * - 遇到右括號：與棧頂的左括號匹配
 * - 如果匹配成功，彈出棧頂；如果失敗，返回 false
 * - 最終檢查棧是否為空
 * 
 * 3. **詳細步驟**：
 * Step 1: 初始化一個空棧
 * Step 2: 遍歷字符串中的每個字符
 * Step 3: 遇到左括號 '(', '{', '[' → 推入棧
 * Step 4: 遇到右括號 ')', '}', ']' → 檢查匹配
 * a) 如果棧為空 → 返回 false（沒有左括號可匹配）
 * b) 彈出棧頂元素，檢查是否與當前右括號匹配
 * c) 如果不匹配 → 返回 false
 * Step 5: 遍歷結束後，檢查棧是否為空
 * a) 空棧 → true（所有括號都已匹配）
 * b) 非空 → false（還有未匹配的左括號）
 * 
 * 4. **為什麼使用棧**：
 * - 括號的匹配順序遵循"就近原則"
 * - 最內層的括號最先配對，符合棧的 LIFO 特性
 * - 可以自然處理嵌套結構
 * 
 * 5. **執行過程示例**：
 * 
 * 示例1: s = "([)]" （返回 false）
 * i=0: '(' → 棧: ['(']
 * i=1: '[' → 棧: ['(', '[']
 * i=2: ')' → 棧頂是 '[', 不匹配 → 返回 false
 * 
 * 示例2: s = "([])" （返回 true）
 * i=0: '(' → 棧: ['(']
 * i=1: '[' → 棧: ['(', '[']
 * i=2: ']' → 棧頂是 '[', 匹配 → 棧: ['(']
 * i=3: ')' → 棧頂是 '(', 匹配 → 棧: []
 * 結束: 棧為空 → 返回 true
 * 
 * 6. **邊界情況處理**：
 * - 空字符串：直接返回 true
 * - 只有右括號：棧為空時遇到右括號，返回 false
 * - 只有左括號：最終棧不為空，返回 false
 * - 括號類型不匹配：isMatching 方法處理
 * 
 * 7. **複雜度分析**：
 * - 時間複雜度：O(n)，其中 n 是字符串長度，需要遍歷一次
 * - 空間複雜度：O(n)，最壞情況下（全是左括號）棧的大小為 n
 * 
 * 8. **算法優化說明**：
 * - 使用 char 數組遍歷比逐個charAt()更高效
 * - 可以提前判斷：如果字符串長度為奇數，直接返回 false
 * - 輔助方法 isMatching 提高代碼可讀性
 * 
 * 9. **關鍵理解點**：
 * - 棧的應用場景：處理具有"配對"或"嵌套"特性的問題
 * - 括號匹配的本質：維護一個"待匹配"的左括號序列
 * - 匹配失敗的情況：類型不匹配、缺少左括號、剩餘左括號
 * 
 * 這道題是理解棧數據結構應用的經典例題，掌握了這個思路，
 * 類似的配對匹配問題都可以用相同的模式解決。
 */