import java.util.*;

class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<>();
        // 開始回溯，初始狀態：空字符串，0個左括號，0個右括號
        backtrack(result, "", 0, 0, n);
        return result;
    }

    /**
     * 回溯函數
     * 
     * @param result  存儲所有有效組合的結果集
     * @param current 當前構建中的字符串
     * @param open    已經添加的左括號數量
     * @param close   已經添加的右括號數量
     * @param max     總共需要的括號對數（n）
     */
    private void backtrack(List<String> result, String current, int open, int close, int max) {
        // 基礎情況：如果當前字符串長度等於 2*n，說明已經用完所有括號
        if (current.length() == max * 2) {
            result.add(current);
            return;
        }

        // 選擇1：添加左括號
        // 條件：左括號數量還沒達到 n 個
        if (open < max) {
            backtrack(result, current + "(", open + 1, close, max);
        }

        // 選擇2：添加右括號
        // 條件：右括號數量必須少於左括號數量（保證括號匹配）
        if (close < open) {
            backtrack(result, current + ")", open, close + 1, max);
        }
    }
}

/*
 * 解題邏輯與思路詳解：
 * 
 * 【核心思路】：回溯算法 (Backtracking) + 剪枝優化
 * 
 * 1. **問題分析**：
 * - 需要生成所有可能的有效括號組合
 * - 有效括號的條件：每個左括號都有對應的右括號，且順序正確
 * - 這是一個組合生成問題，適合用回溯算法解決
 * 
 * 2. **回溯算法框架**：
 * - 做選擇：在當前位置添加左括號或右括號
 * - 遞歸：進入下一層決策
 * - 撤銷選擇：回到上一層狀態（通過參數傳遞自然實現）
 * 
 * 3. **關鍵約束條件**：
 * - 左括號數量不能超過 n
 * - 右括號數量不能超過左括號數量
 * - 總長度達到 2n 時結束
 * 
 * 4. **算法步驟詳解**：
 * Step 1: 初始化結果集和回溯參數
 * Step 2: 在每個位置做出選擇：
 * a) 如果左括號數 < n，可以添加左括號
 * b) 如果右括號數 < 左括號數，可以添加右括號
 * Step 3: 遞歸進入下一層決策
 * Step 4: 當字符串長度 = 2n 時，添加到結果集
 * 
 * 5. **決策樹分析**（以 n=2 為例）：
 * 
 * ""
 * / \
 * "(" (invalid)
 * / \
 * "((" "()"
 * / \ / \
 * "(()" X "()(" "()()"
 * / | | |
 * "(())" | "()()" (done)
 * (done) | (done)
 * X
 * 
 * 每個節點代表一個狀態，邊代表添加括號的選擇
 * X 表示不滿足約束條件的路徑被剪枝
 * 
 * 6. **執行過程示例**（n=2）：
 * 
 * 調用：backtrack([], "", 0, 0, 2)
 * 
 * 第1層：current="", open=0, close=0
 * - 可以加'('：backtrack([], "(", 1, 0, 2)
 * 
 * 第2層：current="(", open=1, close=0
 * - 可以加'('：backtrack([], "((", 2, 0, 2)
 * - 可以加')'：backtrack([], "()", 1, 1, 2)
 * 
 * 分支1：current="((", open=2, close=0
 * - 只能加')'：backtrack([], "(()", 2, 1, 2)
 * - 繼續加')'：backtrack([], "(())", 2, 2, 2)
 * - 長度=4，添加到結果："(())"
 * 
 * 分支2：current="()", open=1, close=1
 * - 可以加'('：backtrack([], "()(", 2, 1, 2)
 * - 繼續加')'：backtrack([], "()()", 2, 2, 2)
 * - 長度=4，添加到結果："()()"
 * 
 * 最終結果：["(())", "()()"]
 * 
 * 7. **剪枝優化**：
 * - 提前終止無效路徑：當 close > open 時不繼續
 * - 避免生成不必要的狀態：當 open > max 時不繼續
 * - 這些剪枝大大減少了搜索空間
 * 
 * 8. **複雜度分析**：
 * - 時間複雜度：O(4^n / √n)，這是第 n 個卡塔蘭數的漸近表達
 * 實際上是生成所有有效括號組合的數量
 * - 空間複雜度：O(n)，遞歸深度最多為 2n，plus 字符串存儲
 * 
 * 9. **為什麼使用字符串拼接**：
 * - Java 中字符串不可變，current + "(" 會創建新字符串
 * - 這自然實現了回溯中的"撤銷"操作
 * - 也可以使用 StringBuilder，但需要手動撤銷
 * 
 * 10. **算法特點**：
 * - 系統性：遍歷所有可能的組合
 * - 高效性：通過剪枝避免無效計算
 * - 遞歸性：子問題結構相同
 * - 約束性：每步都檢查有效性條件
 * 
 * 11. **擴展思考**：
 * - 可以修改約束條件生成其他類型的有效序列
 * - 是動態規劃的遞歸版本（可以用 DP 優化）
 * - 體現了"生成所有可能解"類問題的通用思路
 * 
 * 12. **核心理解**：
 * - 回溯 = 暴力枚舉 + 剪枝優化
 * - 通過約束條件保證生成的都是有效解
 * - 遞歸結構讓複雜問題變得簡潔清晰
 * 
 * 這道題完美展示了回溯算法的精髓：在保證正確性的前提下，
 * 通過智能剪枝大幅提高效率，是學習回溯思想的絕佳例題。
 */