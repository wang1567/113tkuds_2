class Solution {
    public int removeDuplicates(int[] nums) {
        // 若陣列為空或只有一個元素，直接返回長度
        if (nums.length == 0) {
            return 0;
        }

        // 使用指針 k 追蹤唯一元素的插入位置
        int k = 1; // 第一個元素一定是唯一的

        // 遍歷陣列，從第二個元素開始
        for (int i = 1; i < nums.length; i++) {
            // 如果當前元素與前一個元素不同
            if (nums[i] != nums[i - 1]) {
                // 將當前元素放入 k 位置
                nums[k] = nums[i];
                // 增加唯一元素計數
                k++;
            }
        }

        return k;
    }
}

/*
 * 解題說明與邏輯：
 * 
 * 問題理解：
 * - 給定一個按非遞減順序排序的整數陣列
 * - 需要原地移除重複元素，使每個唯一元素只出現一次
 * - 保持元素的相對順序不變
 * - 返回唯一元素的數量 k
 * - 前 k 個元素應包含所有唯一元素，後面元素內容不重要
 * 
 * 解法思路：
 * 1. 處理基礎情況：
 * - 若陣列為空，返回 0
 * - 若陣列只有一個元素，返回 1
 * 
 * 2. 使用雙指針技術：
 * - k 指針：追蹤下一個唯一元素應插入的位置
 * - i 指針：遍歷陣列檢查每個元素
 * - 初始時 k=1，因為第一個元素一定是唯一的
 * 
 * 3. 主要邏輯：
 * - 從第二個元素（i=1）開始遍歷
 * - 若當前元素 nums[i] 與前一個元素 nums[i-1] 不同：
 * 將 nums[i] 複製到 nums[k]
 * 遞增 k
 * - 若元素相同，跳過（不改變 k）
 * 
 * 4. 返回結果：
 * - k 表示唯一元素的數量
 * - 陣列的前 k 個元素已包含所有唯一元素
 * 
 * 時間複雜度：O(n)，其中 n 為陣列長度
 * - 只需要單次遍歷陣列
 * - 每個元素最多檢查一次
 * 
 * 空間複雜度：O(1)
 * - 原地操作，僅使用常數額外的空間
 * - 不需要額外的陣列或數據結構
 * 
 * 範例演練 (nums=[0,0,1,1,1,2,2,3,3,4])：
 * 1. 初始：k=1, nums[0]=0
 * 2. i=1, nums[1]=0, 等於前一個，跳過
 * 3. i=2, nums[2]=1, 不同，將 1 放入 nums[1], k=2
 * 4. i=3, nums[3]=1, 等於前一個，跳過
 * 5. i=4, nums[4]=1, 等於前一個，跳過
 * 6. i=5, nums[5]=2, 不同，將 2 放入 nums[2], k=3
 * 7. i=6, nums[6]=2, 等於前一個，跳過
 * 8. i=7, nums[7]=3, 不同，將 3 放入 nums[3], k=4
 * 9. i=8, nums[8]=3, 等於前一個，跳過
 * 10. i=9, nums[9]=4, 不同，將 4 放入 nums[4], k=5
 * 11. 最終：k=5, nums=[0,1,2,3,4,...,...]
 */