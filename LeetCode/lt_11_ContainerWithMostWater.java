public class lt_11_ContainerWithMostWater {
    public int maxArea(int[] height) {
        int left = 0; // 左指針從最左邊開始
        int right = height.length - 1; // 右指針從最右邊開始
        int maxWater = 0; // 記錄最大蓄水量

        // 使用雙指針法，當左指針小於右指針時繼續搜索
        while (left < right) {
            // 計算當前容器的蓄水量
            // 寬度 = right - left
            // 高度 = 兩條線中較短的那一條 (木桶短板原理)
            int currentWater = (right - left) * Math.min(height[left], height[right]);

            // 更新最大蓄水量
            maxWater = Math.max(maxWater, currentWater);

            // 移動指針的策略：移動較短的那一邊
            // 因為移動較長的一邊不可能得到更大的面積
            if (height[left] < height[right]) {
                left++; // 左邊較短，移動左指針
            } else {
                right--; // 右邊較短或相等，移動右指針
            }
        }

        return maxWater;
    }
}

/*
 * 解題邏輯與思路說明：
 * 
 * 1. 問題理解：
 * - 我們有 n 條垂直線，要找兩條線形成的容器能裝最多水
 * - 容器的容量 = 兩線之間的距離(寬) × 兩線中較短者的高度(高)
 * - 這是因為水會從較短的線溢出(木桶短板原理)
 * 
 * 2. 暴力解法的問題：
 * - 可以用雙重迴圈檢查所有可能的線段組合
 * - 時間複雜度：O(n²)，在大數據量下會超時
 * 
 * 3. 優化解法 - 雙指針法：
 * - 使用兩個指針，一個從左端開始(left)，一個從右端開始(right)
 * - 初始狀態下，寬度是最大的，但高度可能不是最優的
 * - 每次移動較短的那一邊的指針，因為：
 * a) 如果移動較長的一邊，寬度減少，高度不會增加(仍受短邊限制)，面積必然減少
 * b) 如果移動較短的一邊，雖然寬度減少，但可能遇到更高的線，使整體面積增加
 * 
 * 4. 算法正確性證明：
 * - 雙指針法不會錯過最優解
 * - 當我們移動較短邊的指針時，我們實際上排除了所有以當前較短邊為容器邊界的解
 * - 這些被排除的解都不可能比當前解更好，因為它們的高度受限於當前較短邊，
 * 而寬度又比當前寬度小
 * 
 * 5. 時間複雜度：O(n) - 每個元素最多被訪問一次
 * 空間複雜度：O(1) - 只使用常數額外空間
 * 
 * 6. 舉例說明 height = [1,8,6,2,5,4,8,3,7]：
 * - 初始：left=0(高度1), right=8(高度7), 面積 = 8 × min(1,7) = 8
 * - 移動left(因為1<7)：left=1(高度8), right=8(高度7), 面積 = 7 × min(8,7) = 49
 * - 繼續移動right(因為7<8)，直到找到最大面積49
 */