import java.util.HashMap;
import java.util.Map;

public class lt_13_RomantoInteger {
    public int romanToInt(String s) {
        // 建立羅馬數字符號到數值的映射表
        Map<Character, Integer> romanMap = new HashMap<>();
        romanMap.put('I', 1);
        romanMap.put('V', 5);
        romanMap.put('X', 10);
        romanMap.put('L', 50);
        romanMap.put('C', 100);
        romanMap.put('D', 500);
        romanMap.put('M', 1000);

        int result = 0;
        int n = s.length();

        // 從左到右遍歷羅馬數字字串
        for (int i = 0; i < n; i++) {
            int currentValue = romanMap.get(s.charAt(i));

            // 檢查是否需要使用減法規則
            // 如果當前字符的值小於下一個字符的值，則使用減法
            if (i + 1 < n && currentValue < romanMap.get(s.charAt(i + 1))) {
                result -= currentValue; // 減去當前值（減法情況）
            } else {
                result += currentValue; // 加上當前值（正常情況）
            }
        }

        return result;
    }
}

/*
 * 解題邏輯與思路說明：
 * 
 * 1. 問題理解：
 * - 將羅馬數字字串轉換為對應的整數
 * - 羅馬數字通常按從大到小的順序排列
 * - 特殊情況：減法規則，如 IV(4), IX(9), XL(40), XC(90), CD(400), CM(900)
 * - 當較小的數字出現在較大數字前面時，需要進行減法運算
 * 
 * 2. 核心策略 - 從左到右掃描：
 * - 遍歷字串中的每個字符
 * - 比較當前字符與下一個字符的大小關係
 * - 根據大小關係決定是加法還是減法操作
 * 
 * 3. 算法邏輯：
 * 規則1：如果當前字符的值 < 下一個字符的值 → 減法情況
 * 例如：IV中的I，IX中的I，XL中的X等
 * 規則2：否則 → 正常加法情況
 * 例如：VI中的V，XI中的X等
 * 
 * 4. 算法步驟詳解：
 * Step 1: 建立字符到數值的映射表
 * Step 2: 初始化結果變數和字串長度
 * Step 3: 遍歷字串中的每個字符
 * Step 4: 獲取當前字符對應的數值
 * Step 5: 判斷是否為減法情況（當前值 < 下一個值）
 * Step 6: 根據判斷結果進行加法或減法操作
 * Step 7: 返回最終結果
 * 
 * 5. 舉例說明 s = "MCMXCIV"：
 * - M(1000): 1000 > C(100) → result = 0 + 1000 = 1000
 * - C(100): 100 < M(1000) → result = 1000 - 100 = 900
 * - M(1000): 1000 > X(10) → result = 900 + 1000 = 1900
 * - X(10): 10 < C(100) → result = 1900 - 10 = 1890
 * - C(100): 100 > I(1) → result = 1890 + 100 = 1990
 * - I(1): 1 < V(5) → result = 1990 - 1 = 1989
 * - V(5): 最後一個字符 → result = 1989 + 5 = 1994
 * 
 * 6. 時間與空間複雜度：
 * - 時間複雜度：O(n)，其中 n 是字串長度，需要遍歷一次
 * - 空間複雜度：O(1)，使用固定大小的HashMap存儲映射關係
 * 
 * 7. 邊界情況處理：
 * - 單個字符："I" → 1
 * - 全是加法："VIII" → 8
 * - 全是減法："IV" → 4
 * - 混合情況："MCMXCIV" → 1994
 * 
 * 8. 算法優勢：
 * - 簡潔明了：只需要一次遍歷
 * - 邏輯清晰：通過比較相鄰字符判斷加減操作
 * - 效率高：線性時間複雜度
 * - 容錯性好：適用於所有有效的羅馬數字
 * 
 * 9. 關鍵洞察：
 * - 羅馬數字的減法規則本質上是"小數在大數前面"
 * - 通過比較相鄰字符的大小關係，可以準確識別何時使用減法
 * - 這種方法避免了複雜的特殊情況處理，具有很好的通用性
 * 
 * 10. 替代解法思考：
 * - 也可以使用從右到左掃描的方法
 * - 或者預先定義所有減法組合進行字串替換
 * - 但當前解法是最直觀且效率最高的方案
 */